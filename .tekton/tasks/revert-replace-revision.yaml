apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: revert-replace-revision
spec:
  description: |
    revert the target revision patch from the component
  params:
    - name: TARGET_GH_OWNER
      description: Owner of GitHub repository of the infra-deployments code
      default: prietyc123
    - name: TARGET_GH_REPO
      description: GitHub repository of the infra-deployments code
      default: infra-deployments
    - name: shared-secret
      default: infra-deployments-pr-creator
      description: secret in the namespace which contains private key for the GitHub App
    - name: source_branch
    - name: GITHUB_APP_ID
      description: ID of Github app used for updating PR
      default: "288147"
    - name: GITHUB_APP_INSTALLATION_ID
      description: Installation ID of Github app in the organization
      default: "33726981"
  workspaces:
   - name: infra-deployment-git
   - name: shared-file-path
  volumes:
    - name: infra-deployments-pr-creator
      secret:
        # 'private-key' - private key for Github app
        secretName: $(params.shared-secret)
  steps:
    - name: revert-replace-target-revision
      image: quay.io/openshift-pipeline/ci
      workingDir: $(workspaces.infra-deployment-git.path)
      script: |
        #!/usr/bin/env sh
        set -o errexit
        set -o nounset
        set -o pipefail

        # Read each line from the component file, which has all the application details from sync app task e.g {pipeline-service: pipeline-service-stone-stg-m01}
        while IFS= read -r line
        do
          component="$line"
          component=$(echo -e "$component" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
          
          # Set the delimiter to separate componentapp and app name
          IFS=":"
          read -ra app <<< "$component"
          
          app_directory=$(find "$(pwd)/argo-cd-apps/base" -type d -name ${app[0]})
          patch_file_paths=("$app_directory/test-app-patch.yaml" "$app_directory/test-appset-patch.yaml")
          for patch_file_path in "${patch_file_paths[@]}"; do
            # Check if the patch file already exists
            if [ -e "$patch_file_path" ]; then
              # File exists, then delete it
              rm "$patch_file_path"
              echo "Existing patch file '$patch_file_path' deleted."
            fi
          done

          # delete the patches from kustomization
          sed -i -e '/^patches:/,/^- path: test-app-patch.yaml$/d' "$app_directory/kustomization.yaml"
          echo "Patch content removed from '$app_directory/kustomization.yaml'"
        done < "$(workspaces.shared-file-path.path)/component.txt"
    - name: get-diff-files
      image: quay.io/openshift-pipeline/ci
      workingDir: $(workspaces.infra-deployment-git.path)
      script: |
        #!/usr/bin/env sh
        set -o errexit
        set -o nounset
        set -o pipefail

        git config --global --add safe.directory $(workspaces.infra-deployment-git.path)
        git status -s --porcelain | cut -c4- > $(workspaces.shared-file-path.path)/diff-files.txt  
    - name: commit-and-push
      image: quay.io/redhat-appstudio/github-app-token@sha256:b4f2af12e9beea68055995ccdbdb86cfe1be97688c618117e5da2243dc1da18e
      workingDir: $(workspaces.infra-deployment-git.path)
      volumeMounts:
        - name: infra-deployments-pr-creator
          mountPath: /secrets/deploy-key
      env:
        - name: GITHUBAPP_KEY_PATH
          value: /secrets/deploy-key/private-key
        - name: GITHUBAPP_APP_ID
          value: "$(params.GITHUB_APP_ID)"
        - name: GITHUBAPP_INSTALLATION_ID
          value: "$(params.GITHUB_APP_INSTALLATION_ID)"
        - name: GITHUB_API_URL
          value: https://api.github.com
        - name: SOURCE_BRANCH
          value: $(params.source_branch)
        - name: TARGET_GH_OWNER
          value: "$(params.TARGET_GH_OWNER)"
        - name: TARGET_GH_REPO
          value: "$(params.TARGET_GH_REPO)"
      script: |
        #!/usr/bin/env python3
        import json
        import os
        import time
        import base64
        import subprocess
        import requests
        from jwcrypto import jwk, jwt
        EXPIRE_MINUTES_AS_SECONDS = int(os.environ.get('GITHUBAPP_TOKEN_EXPIRATION_MINUTES', 10)) * 60
        # TODO support github enterprise
        GITHUB_API_URL = os.environ["GITHUB_API_URL"]
        TARGET_GH_REPO = os.environ["TARGET_GH_REPO"]
        TARGET_GH_OWNER = os.environ["TARGET_GH_OWNER"]
        class GitHub():
            token = None
            def __init__(self, private_key, app_id=None, installation_id=None):
                if not isinstance(private_key, bytes):
                    raise ValueError(f'"{private_key}" parameter must be byte-string')
                self._private_key = private_key
                self.app_id = app_id
                self.token = self._get_token(installation_id)
            def _load_private_key(self, pem_key_bytes):
                return jwk.JWK.from_pem(pem_key_bytes)
            def _app_token(self, expire_in=EXPIRE_MINUTES_AS_SECONDS):
                key = self._load_private_key(self._private_key)
                now = int(time.time())
                token = jwt.JWT(
                    header={"alg": "RS256"},
                    claims={
                        "iat": now,
                        "exp": now + expire_in,
                        "iss": self.app_id
                    },
                    algs=["RS256"],
                )
                token.make_signed_token(key)
                return token.serialize()
            def _get_token(self, installation_id=None):
                app_token = self._app_token()
                if not installation_id:
                    return app_token
                req = self._request(
                    "POST",
                    f"/app/installations/{installation_id}/access_tokens",
                    headers={
                        "Authorization": f"Bearer {app_token}",
                        "Accept": "application/vnd.github.machine-man-preview+json"
                    })
                ret = req.json()
                if 'token' not in ret:
                    raise Exception(f"Authentication errors: {ret}")
                return ret['token']
            def _request(self, method, url, headers={}, data={}):
                if self.token and 'Authorization' not in headers:
                    headers.update({"Authorization": "Bearer " + self.token})
                if not url.startswith("http"):
                    url = f"{GITHUB_API_URL}{url}"
                return requests.request(method,
                                        url,
                                        headers=headers,
                                        data=json.dumps(data))
            def update_pr_branch(self):
                branch = os.environ.get('SOURCE_BRANCH')
                target_branch = self._request("GET", f"/repos/{TARGET_GH_OWNER}/{TARGET_GH_REPO}/git/refs/heads/{branch}").json()
                main_branch_sha = self._request("GET", f"/repos/{TARGET_GH_OWNER}/{TARGET_GH_REPO}/git/refs/heads/main").json()['object']['sha']
                logger.info("Update branch %s", branch)
                self._request(
                    "PATCH",
                    f"/repos/{TARGET_GH_OWNER}/{TARGET_GH_REPO}/git/refs/heads/{branch}",
                    data={"sha": main_branch_sha, "force": True}
                )
            def upload_content(self):
                branch = os.environ.get('SOURCE_BRANCH')
                for file in open('$(workspaces.shared-file-path.path)/diff-files.txt').readlines():
                    file = file.strip()
                    with open(f"{file}", "rb") as fd:
                        encoded_string = base64.b64encode(fd.read()).decode("utf-8")
                    old_sha = self._request("GET", f'/repos/{TARGET_GH_OWNER}/{TARGET_GH_REPO}/contents/{file}').json().get("sha")
                    if old_sha is None:
                        logger.info("Upload a new file %s", file)
                        self._request("PUT", f'/repos/{TARGET_GH_OWNER}/{TARGET_GH_REPO}/contents/{file}', data={"message": f"update {file}", "branch": branch, "content": encoded_string})
                    else:
                        logger.info("Update file %s", file)
                        self._request("PUT", f'/repos/{TARGET_GH_OWNER}/{TARGET_GH_REPO}/contents/{file}', data={"message": f"update {file}", "branch": branch, "content": encoded_string, "sha": old_sha})
        def main():
            with open(os.environ['GITHUBAPP_KEY_PATH'], 'rb') as key_file:
                key = key_file.read()
            if os.environ.get('GITHUBAPP_APP_ID'):
                app_id = os.environ['GITHUBAPP_APP_ID']
            else:
                raise Exception("application id is not set")
            print(f"Getting user token for application_id: {app_id}")
            github_app = GitHub(
                key,
                app_id=app_id,
                installation_id=os.environ.get('GITHUBAPP_INSTALLATION_ID'))
            github_app.create_reset_branch()
            github_app.upload_content()
        if __name__ == '__main__':
            main()
